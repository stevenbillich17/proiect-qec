import os
import json

from flask import Flask, send_file, request, jsonify

from src.quantum.quantum_encoder import ConvolutionalEncoder
from src.quantum.helpers import explain_generator_taps

app = Flask(__name__)

encoder = None
# This list will store all events generated by the encoder instance
all_encoder_events = []

def flask_encoder_listener(event_data):
    """Appends the full event data dictionary to our global list."""
    global all_encoder_events
    all_encoder_events.append(event_data)
    # Optional: server-side logging for debugging
    # print(f"Flask Listener Captured Event: {event_data.get('type')}")


@app.route("/")
def index():
    return send_file('src/index.html')

def main():
    # Ensure the ConvolutionalEncoder class is defined or imported before this point
    app.run(port=int(os.environ.get('PORT', 80))) # Using 8080, common for dev

@app.route('/set_generator', methods=['POST'])
def set_generator():
    global encoder, all_encoder_events
    data = request.get_json()

    generators_str = data.get('generators', '')
    message_str = data.get('message', '')
    try:
        constraint_length = int(data.get('constraint_length', 3)) # Get K
    except ValueError:
        return jsonify({"status": "error", "message": "Invalid Constraint Length (K). Must be an integer."}), 400


    try:
        generators = [g.strip() for g in generators_str.split(',') if g.strip()]
        if not generators:
            raise ValueError("Generators cannot be empty.")

        # Validate message bits (allow empty for now, encoder handles it)
        parsed_message_bits = []
        if message_str.strip(): # If message string is not empty after stripping whitespace
            raw_bits = message_str.replace(' ', '')
            if not all(c in '01' for c in raw_bits): # Check if all characters are 0 or 1
                raise ValueError("Message bits must only contain 0s and 1s.")
            parsed_message_bits = [int(bit) for bit in raw_bits]


        # Pad the message with K-1 zeros for flushing the encoder's memory
        message_to_encode_padded = list(parsed_message_bits) # Make a copy
        if constraint_length > 1:
            padding_length = constraint_length - 1
            message_to_encode_padded.extend([0] * padding_length)
        
        all_encoder_events = [] # Clear previous events
        encoder = ConvolutionalEncoder(constraint_length=constraint_length, generators_octal=generators)
        encoder.add_listener(flask_encoder_listener) # Add our Flask-specific listener
        
        encoder.load_message(message_to_encode_padded) # This will trigger the MESSAGE_LOADED event

        initial_event = all_encoder_events[0] if all_encoder_events else None # Should be MESSAGE_LOADED

        return jsonify({
            "status": "success",
            "message": "Encoder initialized and message loaded.",
            "initial_event": initial_event, # Send the MESSAGE_LOADED event details
            "config": {
                "constraint_length": encoder.constraint_length,
                "generators_octal": encoder.generators_octal,
                "binary_generators": [''.join(map(str,bg)) for bg in encoder.binary_generators],
                "original_message_length": len(parsed_message_bits),
                "padded_message_length": len(message_to_encode_padded)
            }
        })
    except ValueError as e: # Catch specific ValueErrors from Encoder or parsing
        return jsonify({"status": "error", "message": str(e)}), 400
    except Exception as e: # Catch any other unexpected errors
        return jsonify({"status": "error", "message": f"An unexpected error occurred: {str(e)}"}), 500


@app.route('/next_step', methods=['POST'])
def next_step():
    global encoder, all_encoder_events

    if encoder is None:
        return jsonify({"status": "error", "message": "Encoder not initialized. Set generator first."}), 400

    # Record how many events we had before this step
    num_events_before_step = len(all_encoder_events)

    step_outcome = encoder.go_to_next_step() # This call will trigger the listener

    # Extract newly added events by this step's execution
    newly_generated_events = all_encoder_events[num_events_before_step:]

    primary_event_for_step = None
    if newly_generated_events:
        # Try to find ENCODE_STEP or ENCODING_COMPLETE as the primary event
        for e in reversed(newly_generated_events):
            if e.get("type") in ["ENCODE_STEP", "ENCODING_COMPLETE"]:
                primary_event_for_step = e
                break
        if not primary_event_for_step: # Fallback to the very last new event
            primary_event_for_step = newly_generated_events[-1]
            
    return jsonify({
        "status_from_method": step_outcome["status"], 
        "details_from_method": step_outcome.get("details"),
        "output_bits_from_method": step_outcome.get("output_bits"), # Output of just this step
        "primary_event": primary_event_for_step, # The rich event object for this step
        "encoder_state_after_step": { # Fresh snapshot of key encoder states
            "memory": encoder.get_current_memory(),
            "accumulated_output": encoder.get_current_encoded_data(),
            "message_pointer": encoder.get_current_message_pointer(),
            "is_complete": encoder.is_current_message_fully_encoded(),
            "message_length": len(encoder.get_current_message()) if encoder.get_current_message() else 0
        }
    })

if __name__ == "__main__":
    # Make sure ConvolutionalEncoder is defined or imported above.
    # The 'helpers' import might need adjustment based on your project structure.
    # For this example, I've included ConvolutionalEncoder directly in this file.
    # If helpers.py is not in PYTHONPATH, you might get an ImportError for explain_generator_taps
    # For the Flask app itself, it's not directly used unless called, so it might not break server start.
    main()