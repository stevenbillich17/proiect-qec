<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Convolutional Coder Visualization</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; }
        .tab-container { display: flex; margin-bottom: 10px; border-bottom: 1px solid #ccc; }
        .tab-button { padding: 10px 20px; cursor: pointer; border: none; background-color: transparent; font-size: 16px; border-bottom: 3px solid transparent; }
        .tab-button.active { border-bottom: 3px solid #007bff; font-weight: bold; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .container { display: flex; gap: 20px; flex-wrap: wrap; }
        .controls, .state, .decoder-state-display { border: 1px solid #ccc; padding: 15px; border-radius: 5px; background-color: #fff; box-shadow: 0 0 10px rgba(0,0,0,0.05); margin-bottom: 20px;}
        .controls { width: 100%; max-width: 350px; }
        .state, .decoder-state-display { flex-grow: 1; min-width: 300px; }
        .step-output, .decoder-step-output { flex-basis: 100%; margin-top: 10px; min-height: 150px; white-space: pre-wrap; background-color: #f9f9f9; border: 1px solid #ddd; padding:10px; border-radius: 5px; max-height: 400px; overflow-y: auto;}
        
        h1, h2, h3 { margin-top: 0; color: #333; }
        h3 { font-size: 1.1em; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-bottom:10px; }
        label { display: block; margin-top: 10px; font-weight: bold; color: #555; }
        input[type="text"], input[type="number"], textarea, select { width: calc(100% - 18px); padding: 8px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px; }
        textarea { min-height: 60px; }
        button { padding: 10px 15px; margin-top: 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .error-message { color: red; font-weight: bold; margin-top:10px; }
        #stepGeneratorCalculations div, .decoder-event-detail div, .encoder-event-detail div { margin-left: 15px; border-left: 2px solid #eee; padding-left: 10px; margin-bottom:8px;}
        .mono { font-family: "Courier New", Courier, monospace; background-color: #eef; padding: 2px 4px; border-radius: 3px; }
        .event-log-entry { border-bottom: 1px dashed #ddd; padding-bottom: 10px; margin-bottom: 10px; }
        .event-log-entry:last-child { border-bottom: none; }
        .flex-row { display: flex; align-items: center; gap: 10px; }
        .flex-row input[type="checkbox"] { margin-top: 0; }
        .puncturing-info { margin-top: 10px; padding: 5px; background-color: #e9ecef; border-radius: 3px;}
    </style>
</head>
<body>
    <h1>Convolutional Coder Step-by-Step Visualization</h1>

    <div class="tab-container">
        <button class="tab-button active" onclick="openTab(event, 'encoderTab')">Encoder</button>
        <button class="tab-button" onclick="openTab(event, 'decoderTab')">Viterbi Decoder (K=7, G=171,133)</button>
    </div>

    <!-- Encoder Tab -->
    <div id="encoderTab" class="tab-content active">
        <div class="container">
            <div class="controls">
                <h2>Encoder Setup</h2>
                <div>
                    <label for="constraintLength">Constraint Length (K):</label>
                    <input type="number" id="constraintLength" value="7" min="1">
                </div>
                <div>
                    <label for="generators">Generators (octal, comma-separated):</label>
                    <input type="text" id="generators" value="171,133" placeholder="e.g., 7,5">
                </div>
                <div> <!-- Puncturing Controls -->
                    <label for="puncturingScheme">Puncturing Scheme:</label>
                    <select id="puncturingScheme">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <div>
                    <label for="binaryMessage">Binary Message (0s and 1s):</label>
                    <input type="text" id="binaryMessage" placeholder="e.g., 1011">
                </div>
                <button id="setGeneratorButton">Initialize Encoder & Load Message</button>
                <button id="nextStepButton" disabled>Next Encoding Step</button>
                <p id="errorMessage" class="error-message"></p>
            </div>

            <div class="state">
                <h2>Encoder Live State</h2>
                <p>Constraint Length (K): <span id="stateK" class="mono">N/A</span></p>
                <p>Generators (Octal): <span id="stateGeneratorsOctal" class="mono">N/A</span></p>
                <p>Generators (Binary): <span id="stateGeneratorsBinary" class="mono">N/A</span></p>
                <div class="puncturing-info">
                    Puncturing: <span id="statePuncturingActive" class="mono">No</span><br>
                    Scheme: <span id="statePuncturingScheme" class="mono">N/A</span>
                </div>
                <hr>
                <p>Full Message (padded): <span id="stateLoadedMessage" class="mono">N/A</span></p>
                <p>Input Bit Pointer: <span id="stateMessagePointer" class="mono">0</span> / <span id="stateMessageLength" class="mono">0</span></p>
                <p>Current Memory: <span id="stateMemory" class="mono">N/A</span></p>
                <p>Accumulated Output (Punctured): <span id="stateAccumulatedOutput" class="mono">N/A</span></p>
                <p>Encoding Complete: <span id="stateEncodingComplete" class="mono">No</span></p>
            </div>
        </div>
        <div class="step-output">
            <h2>Encoder: Last Step Details & Notifications</h2>
            <div id="notifications" class="encoder-event-detail"></div>
        </div>
    </div>

    <!-- Decoder Tab (Unchanged from previous version) -->
    <div id="decoderTab" class="tab-content">
        <!-- ... (Decoder HTML as before) ... -->
        <div class="container">
            <div class="controls">
                <h2>Decoder Setup & Control</h2>
                <div>
                    <label for="receivedSequence">Received Sequence (binary, e.g., 011011...):</label>
                    <textarea id="receivedSequence" placeholder="Enter binary sequence (0s and 1s)"></textarea>
                </div>
                <div>
                    <label for="numOriginalBits">Number of Original Message Bits:</label>
                    <input type="number" id="numOriginalBits" value="0" min="0">
                </div>
                <button id="loadSequenceButton">Load Sequence & Initialize</button>
                <button id="nextAcsStepButton" disabled>Next ACS Step</button>
                <div class="flex-row">
                    <button id="performTracebackButton" disabled>Perform Traceback</button>
                    <input type="checkbox" id="assumeZeroTerminated" checked style="margin-left:10px; margin-top:15px;">
                    <label for="assumeZeroTerminated" style="margin-top:15px; font-weight:normal;">Assume Zero Terminated</label>
                </div>
                <button id="resetDecoderButton">Reset Decoder</button>
                <p id="decoderErrorMessage" class="error-message"></p>
            </div>

            <div class="decoder-state-display">
                <h2>Decoder Live State</h2>
                <p>Fixed K: <span id="decoderStateK" class="mono">7</span></p>
                <p>Fixed Generators (Octal): <span id="decoderStateGenerators" class="mono">171, 133</span></p>
                <p>Num States: <span id="decoderStateNumStates" class="mono">64</span></p>
                <hr>
                <p>Sequence Loaded: <span id="decoderStateSeqLoaded" class="mono">No</span></p>
                <p>Original Message Bits (Expected): <span id="decoderStateNumOrigBits" class="mono">N/A</span></p>
                <p>Trellis Stages: <span id="decoderStateCurrentStage" class="mono">0</span> / <span id="decoderStateTotalStages" class="mono">0</span></p>
                <p>ACS Complete: <span id="decoderStateAcsComplete" class="mono">No</span></p>
                <p>Traceback Complete: <span id="decoderStateTracebackComplete" class="mono">No</span></p>
                <p>Final Decoded Message: <span id="decoderStateDecodedMessage" class="mono">N/A</span></p>
                <p>Path Metrics (State 0): <span id="decoderStatePM0" class="mono">N/A</span></p>
            </div>
        </div>
        <div class="decoder-step-output">
            <h2>Decoder: Last Step Details & Notifications</h2>
            <div id="decoderNotifications"></div>
        </div>
    </div>


<script>
    // --- Tab Handling ---
    function openTab(evt, tabName) {
        var i, tabcontent, tabbuttons;
        tabcontent = document.getElementsByClassName("tab-content");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
            tabcontent[i].classList.remove("active");
        }
        tabbuttons = document.getElementsByClassName("tab-button");
        for (i = 0; i < tabbuttons.length; i++) {
            tabbuttons[i].classList.remove("active");
        }
        document.getElementById(tabName).style.display = "block";
        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.classList.add("active");
    }
    
    // --- General Helper ---
    function formatPathMetric(value) {
        if (value === null) return "Infinity";
        if (typeof value === 'number') return value.toFixed(2);
        return "N/A";
    }

    // --- Encoder JS ---
    const setGeneratorButton = document.getElementById('setGeneratorButton');
    const nextStepButton = document.getElementById('nextStepButton');
    const constraintLengthInput = document.getElementById('constraintLength');
    const binaryMessageInput = document.getElementById('binaryMessage');
    const generatorsInput = document.getElementById('generators');
    const puncturingSchemeSelect = document.getElementById('puncturingScheme'); // New
    const errorMessageDiv = document.getElementById('errorMessage');
    const notificationsDiv = document.getElementById('notifications');

    const stateK = document.getElementById('stateK');
    const stateGeneratorsOctal = document.getElementById('stateGeneratorsOctal');
    const stateGeneratorsBinary = document.getElementById('stateGeneratorsBinary');
    const statePuncturingActive = document.getElementById('statePuncturingActive'); // New
    const statePuncturingScheme = document.getElementById('statePuncturingScheme'); // New
    const stateLoadedMessage = document.getElementById('stateLoadedMessage');
    const stateMessagePointer = document.getElementById('stateMessagePointer');
    const stateMessageLength = document.getElementById('stateMessageLength');
    const stateMemory = document.getElementById('stateMemory');
    const stateAccumulatedOutput = document.getElementById('stateAccumulatedOutput');
    const stateEncodingComplete = document.getElementById('stateEncodingComplete');
    let currentK_encoder = 0;
    let predefinedPuncturingSchemes = {}; // To be fetched

    function clearEncoderNotifications() {
        notificationsDiv.innerHTML = '';
        errorMessageDiv.textContent = '';
    }
    function showEncoderError(message) {
        errorMessageDiv.textContent = message;
        notificationsDiv.innerHTML = `<div class="event-log-entry error-message">Error: ${message}</div>`;
    }
    function showEncoderNotification(message, type = 'info') {
        const div = document.createElement('div');
        div.className = 'event-log-entry';
        div.textContent = message;
        if (type === 'success') div.style.color = 'green';
        notificationsDiv.prepend(div);
    }
    function formatEncoderMemory(memoryArray, kVal) {
      const safeMemoryArray = Array.isArray(memoryArray) ? memoryArray : [];
      if (kVal < 1) return "N/A";
      if (kVal === 1) return "[] (No memory cells for K=1)";
      const memoryCells = kVal -1;
      if (memoryCells <= 0) return "[] (No memory cells)";
      let displayBits = safeMemoryArray.slice(0, memoryCells);
      if (displayBits.length < memoryCells) {
          displayBits = displayBits.concat(Array(memoryCells - displayBits.length).fill('?'));
      }
      const labels = [];
      for (let i = 0; i < memoryCells; i++) {
          labels.push(`M<sub>${i}</sub>=${displayBits[i]}`);
      }
      return `[${displayBits.join('')}] (${labels.join(', ')})`;
    }

    function updateEncoderStateDisplayFromServer(encoderState) {
        if (!encoderState || !encoderState.is_initialized) {
            // Default/empty state
            stateK.textContent = 'N/A';
            stateGeneratorsOctal.textContent = 'N/A';
            stateGeneratorsBinary.innerHTML = 'N/A';
            statePuncturingActive.textContent = 'No';
            statePuncturingScheme.textContent = 'N/A';
            stateLoadedMessage.textContent = 'N/A';
            stateMessagePointer.textContent = '0';
            stateMessageLength.textContent = '0';
            stateMemory.innerHTML = formatEncoderMemory([], 0);
            stateAccumulatedOutput.textContent = '[]';
            stateEncodingComplete.textContent = 'No';
            nextStepButton.disabled = true;
            return;
        }

        currentK_encoder = encoderState.constraint_length;
        stateK.textContent = encoderState.constraint_length;
        stateGeneratorsOctal.textContent = (encoderState.generators_octal || []).join(', ');
        stateGeneratorsBinary.innerHTML = (encoderState.binary_generators || []).map(g => `<span class="mono">${g}</span>`).join('<br>');
        
        if (encoderState.puncturer_info) {
            statePuncturingActive.textContent = 'Yes';
            statePuncturingScheme.textContent = encoderState.puncturer_info.label || 'Custom';
        } else {
            statePuncturingActive.textContent = 'No';
            statePuncturingScheme.textContent = 'None';
        }

        stateLoadedMessage.textContent = encoderState.is_message_loaded && encoderState.padded_message_length > 0 ? '(Message Loaded)' : 'N/A'; // Actual message content in event log
        stateMessagePointer.textContent = encoderState.message_pointer;
        stateMessageLength.textContent = encoderState.padded_message_length || 0;
        stateMemory.innerHTML = formatEncoderMemory(encoderState.memory, currentK_encoder);
        stateAccumulatedOutput.textContent = (encoderState.accumulated_output || []).length > 0 ? (encoderState.accumulated_output || []).join('') : '[]';
        stateEncodingComplete.textContent = encoderState.is_complete ? 'Yes' : 'No';
        nextStepButton.disabled = !encoderState.is_initialized || !encoderState.is_message_loaded || encoderState.is_complete;
    }

    function populatePuncturingSchemes(schemes) {
        puncturingSchemeSelect.innerHTML = ''; // Clear existing
        for (const key in schemes) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = schemes[key].label;
            puncturingSchemeSelect.appendChild(option);
        }
    }
    
    async function fetchInitialEncoderConfig() {
        try {
            const response = await fetch('/get_initial_encoder_config');
            if (!response.ok) {
                showEncoderError(`Failed to load initial config: ${response.status}`);
                return;
            }
            const data = await response.json(); // This is the full encoder_state_dict
            predefinedPuncturingSchemes = data.predefined_puncturing_schemes_available || {};
            populatePuncturingSchemes(predefinedPuncturingSchemes);
            updateEncoderStateDisplayFromServer(data); // Pass the whole state dict
        } catch (error) {
            showEncoderError('Network error loading initial config: ' + error.message);
        }
    }


    function displayEncoderEventDetails(eventData) {
        if (!eventData) return;
        const eventDiv = document.createElement('div');
        eventDiv.className = 'event-log-entry';
        let content = `<h3>Event: ${eventData.type}</h3>`;
        switch (eventData.type) {
            case "MESSAGE_LOADED":
                content += `<p class="mono">Message Loaded: ${(eventData.message_loaded || []).join('')} (Length: ${eventData.message_length || 0})</p>`;
                content += `<p>Status: ${eventData.status}</p>`;
                stateLoadedMessage.textContent = (eventData.message_loaded || []).join(''); // Update from event
                stateMessageLength.textContent = eventData.message_length || 0;
                break;
            case "ENCODE_STEP":
                content += `<p><span class="mono">Input Bit: ${eventData.input_bit}</span></p>`;
                content += `<p><span class="mono">Memory Before: ${formatEncoderMemory(eventData.memory_before, currentK_encoder)}</span></p>`;
                // ... (generator details as before) ...
                content += `<p><span class="mono">Unpunctured Output for Step: [${(eventData.unpunctured_output_for_step || []).join(', ')}]</span></p>`;
                if (eventData.is_puncturing_active) {
                    content += `<p class="mono">Punctured Output for Step: [${(eventData.punctured_output_for_step || []).join(', ')}]</span> (Matrix Idx: ${eventData.puncturer_period_index_before_step})</p>`;
                }
                content += `<p><span class="mono">Memory After: ${formatEncoderMemory(eventData.memory_after, currentK_encoder)}</span></p>`;
                break;
            case "ENCODING_COMPLETE":
                content += `<p class="mono">Original Message Processed: ${(eventData.message_processed || []).join('')}</p>`;
                if (eventData.is_puncturing_active && eventData.puncturing_details) {
                    content += `<p class="mono">Puncturing Scheme: ${eventData.puncturing_details.label}</p>`;
                }
                content += `<p class="mono">Full Encoded Output (Punctured): ${(eventData.full_encoded_output || []).join('')}</p>`;
                if (eventData.full_unpunctured_output_pairs) {
                     content += `<p class="mono">Full Unpunctured Output Pairs: ${JSON.stringify(eventData.full_unpunctured_output_pairs)}</p>`;
                }
                showEncoderNotification("Encoding complete!", "success");
                break;
            case "PUNCTURER_CONFIG_CHANGED":
                content += `<p>Puncturing Active: <span class="mono">${eventData.active ? 'Yes' : 'No'}</span></p>`;
                content += `<p>Scheme: <span class="mono">${eventData.scheme_label}</span></p>`;
                if (eventData.puncturing_matrix) {
                    content += `<p class="mono">Matrix: ${JSON.stringify(eventData.puncturing_matrix)}</p>`;
                }
                showEncoderNotification(`Puncturing scheme changed to ${eventData.scheme_label}.`, "info");
                break;
            case "ENCODER_RESET": content += `<p>Status: ${eventData.status}</p>`; break;
            default: content += `<pre>${JSON.stringify(eventData, null, 2)}</pre>`;
        }
        eventDiv.innerHTML = content;
        notificationsDiv.prepend(eventDiv);
    }

    puncturingSchemeSelect.addEventListener('change', async (event) => {
        const schemeKey = event.target.value;
        errorMessageDiv.textContent = '';
        try {
            const response = await fetch('/set_puncturing', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ puncturing_scheme_key: schemeKey })
            });
            const data = await response.json();
            if (!response.ok) {
                showEncoderError(data.message || `Error: ${response.status}`);
            } else {
                showEncoderNotification(data.message, "success");
            }
            if(data.event) displayEncoderEventDetails(data.event);
            if(data.encoder_state) updateEncoderStateDisplayFromServer(data.encoder_state);

        } catch (error) {
            showEncoderError('Network error setting puncturer: ' + error.message);
        }
    });

    setGeneratorButton.addEventListener('click', async () => {
        clearEncoderNotifications();
        const kVal = constraintLengthInput.value;
        const gens = generatorsInput.value;
        const msg = binaryMessageInput.value;
        // Puncturing scheme is already set via its own control /set_puncturing

        if (!kVal || parseInt(kVal) < 1) { 
            showEncoderError("Constraint Length (K) must be an integer >= 1."); return;
        }
        if (!gens.trim()) { showEncoderError("Generators must be provided."); return; }

        try {
            const response = await fetch('/set_generator', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ constraint_length: parseInt(kVal), generators: gens, message: msg }),
            });
            const data = await response.json();
            if (!response.ok) {
                showEncoderError(data.message || `Error: ${response.status}`);
                if(data.encoder_state) updateEncoderStateDisplayFromServer(data.encoder_state);
                else fetchInitialEncoderConfig(); // Fallback to reload default state
                return;
            }
            showEncoderNotification(data.message, "success");
            if (data.initial_event) { displayEncoderEventDetails(data.initial_event); }
            if (data.encoder_state) {
                 updateEncoderStateDisplayFromServer(data.encoder_state);
            }
        } catch (error) { showEncoderError('Network error: ' + error.message); fetchInitialEncoderConfig(); }
    });

    nextStepButton.addEventListener('click', async () => {
        errorMessageDiv.textContent = '';
        try {
            const response = await fetch('/next_step', { method: 'POST' });
            const data = await response.json();
            if (!response.ok) { 
                showEncoderError(data.message || `Error: ${response.status}`);
            } else {
                if (data.details_from_method) { showEncoderNotification(`Status: ${data.status_from_method} - ${data.details_from_method}`); }
            }
            if (data.primary_event) { displayEncoderEventDetails(data.primary_event); }
            if (data.encoder_state) { updateEncoderStateDisplayFromServer(data.encoder_state); }
            
        } catch (error) { showEncoderError('Network error: ' + error.message); }
    });
    
    // --- Decoder JS (Unchanged from previous version) ---
    // ... (all decoder JS code from previous version here) ...
    const loadSequenceButton = document.getElementById('loadSequenceButton');
    const nextAcsStepButton = document.getElementById('nextAcsStepButton');
    const performTracebackButton = document.getElementById('performTracebackButton');
    const resetDecoderButton = document.getElementById('resetDecoderButton');
    const receivedSequenceInput = document.getElementById('receivedSequence');
    const numOriginalBitsInput = document.getElementById('numOriginalBits');
    const assumeZeroTerminatedCheckbox = document.getElementById('assumeZeroTerminated');
    const decoderErrorMessageDiv = document.getElementById('decoderErrorMessage');
    const decoderNotificationsDiv = document.getElementById('decoderNotifications');

    const decoderStateK = document.getElementById('decoderStateK');
    const decoderStateGenerators = document.getElementById('decoderStateGenerators');
    const decoderStateNumStates = document.getElementById('decoderStateNumStates');
    const decoderStateSeqLoaded = document.getElementById('decoderStateSeqLoaded');
    const decoderStateNumOrigBits = document.getElementById('decoderStateNumOrigBits');
    const decoderStateCurrentStage = document.getElementById('decoderStateCurrentStage');
    const decoderStateTotalStages = document.getElementById('decoderStateTotalStages');
    const decoderStateAcsComplete = document.getElementById('decoderStateAcsComplete');
    const decoderStateTracebackComplete = document.getElementById('decoderStateTracebackComplete');
    const decoderStateDecodedMessage = document.getElementById('decoderStateDecodedMessage');
    const decoderStatePM0 = document.getElementById('decoderStatePM0');


    function clearDecoderNotifications() {
        decoderNotificationsDiv.innerHTML = '';
        decoderErrorMessageDiv.textContent = '';
    }
    function showDecoderError(message) {
        decoderErrorMessageDiv.textContent = message;
        decoderNotificationsDiv.innerHTML = `<div class="event-log-entry error-message">Error: ${message}</div>`;
    }
    function showDecoderNotification(message, type = 'info') {
        const div = document.createElement('div');
        div.className = 'event-log-entry';
        div.textContent = message;
        if (type === 'success') div.style.color = 'green';
        else if (type === 'info') div.style.color = 'blue';
        decoderNotificationsDiv.prepend(div);
    }

    function updateDecoderUIFromState(state) {
        if (!state) return;

        if (state.fixed_params) {
            decoderStateK.textContent = state.fixed_params.K;
            decoderStateGenerators.textContent = state.fixed_params.G_octal.join(', ');
            decoderStateNumStates.textContent = state.fixed_params.num_states;
        }

        decoderStateSeqLoaded.textContent = state.is_sequence_loaded ? 'Yes' : 'No';
        decoderStateNumOrigBits.textContent = state.is_sequence_loaded ? state.num_original_message_bits : 'N/A';
        decoderStateCurrentStage.textContent = state.current_trellis_stage_idx;
        decoderStateTotalStages.textContent = state.T_stages_total;
        decoderStateAcsComplete.textContent = state.is_acs_complete ? 'Yes' : 'No';
        decoderStateTracebackComplete.textContent = state.is_traceback_complete ? 'Yes' : 'No';
        
        const decodedMsg = state.decoded_message_final || [];
        decoderStateDecodedMessage.textContent = state.is_traceback_complete ? (decodedMsg.length > 0 ? decodedMsg.join('') : '[] (empty)') : 'N/A';
        
        const pm = state.path_metrics || [];
        decoderStatePM0.textContent = (pm.length > 0) ? formatPathMetric(pm[0]) : 'N/A';

        loadSequenceButton.disabled = false;
        nextAcsStepButton.disabled = !(state.is_sequence_loaded && !state.is_acs_complete && state.T_stages_total > 0);
        performTracebackButton.disabled = !(state.is_sequence_loaded && state.is_acs_complete && state.T_stages_total > 0); // Allow re-traceback
        resetDecoderButton.disabled = false;
    }
    
    function displayDecoderEventDetails(eventData) {
        if (!eventData) return;
        const eventDiv = document.createElement('div');
        eventDiv.className = 'event-log-entry decoder-event-detail';
        let content = `<h3>Event: ${eventData.type}</h3>`;

        switch (eventData.type) {
            case "DECODER_RESET":
                content += `<p>${eventData.status}</p>`;
                break;
            case "DECODER_RECEIVED_SEQUENCE_LOADED":
                content += `<p class="mono">Sequence Loaded: ${(eventData.sequence_loaded || []).join('') || '[]'}</p>`;
                content += `<p>Original Message Bits: ${eventData.num_original_bits}</p>`;
                content += `<p>Total Trellis Stages: ${eventData.total_stages}</p>`;
                if (eventData.initial_path_metrics && eventData.initial_path_metrics.length > 0) {
                     content += `<p class="mono">Initial Path Metric (State 0): ${formatPathMetric(eventData.initial_path_metrics[0])}</p>`;
                }
                break;
            case "DECODER_ACS_STEP":
                content += `<p>Processed Trellis Stage: ${eventData.stage_processed_idx}</p>`;
                content += `<p class="mono">Received Pair for Stage: [${(eventData.received_pair_for_stage || []).join(',')}]</p>`;
                if (eventData.path_metrics_at_stage_end && eventData.path_metrics_at_stage_end.length > 0) {
                    content += `<p class="mono">Path Metric (State 0) after step: ${formatPathMetric(eventData.path_metrics_at_stage_end[0])}</p>`;
                }
                 content += `<p><small>Full PMs and pointers for this step were logged to browser console.</small></p>`;
                 console.log("DECODER_ACS_STEP Event Data:", JSON.parse(JSON.stringify(eventData))); // Deep copy for console
                break;
            case "DECODER_ACS_COMPLETE":
                content += `<p>ACS completed after ${eventData.total_stages_processed} stages.</p>`;
                if (eventData.final_path_metrics_at_T && eventData.final_path_metrics_at_T.length > 0) {
                    content += `<p class="mono">Final Path Metric (State 0): ${formatPathMetric(eventData.final_path_metrics_at_T[0])}</p>`;
                }
                break;
            case "DECODER_TRACEBACK_COMPLETE":
                content += `<p class="mono">Decoded Message: ${(eventData.decoded_message || []).join('') || '[]'}</p>`;
                if (eventData.full_decoded_sequence_with_tail) {
                    content += `<p class="mono">Full Decoded (incl. tail): ${eventData.full_decoded_sequence_with_tail.join('')}</p>`;
                }
                break;
            default:
                content += `<pre>${JSON.stringify(eventData, null, 2)}</pre>`;
        }
        eventDiv.innerHTML = content;
        decoderNotificationsDiv.prepend(eventDiv);
    }

    loadSequenceButton.addEventListener('click', async () => {
        clearDecoderNotifications();
        const sequenceStr = receivedSequenceInput.value;
        const numOrigBits = numOriginalBitsInput.value;

        if (!sequenceStr.trim()) {
            showDecoderError("Received sequence cannot be empty."); return;
        }
        if (!/^[01,\s]*$/.test(sequenceStr)) {
            showDecoderError("Received sequence must contain only 0s, 1s, commas, or spaces."); return;
        }
        const cleanedSequence = sequenceStr.replace(/[^01]/g, "");
        // For decoder, sequence length check is relative to Viterbi's fixed rate 1/2 mother code.
        // If punctured sequence is input, its length might not be even.
        // The ViterbiDecoderK7G171_133_Stepwise expects pairs for its internal logic.
        // This UI is for *that* specific decoder, which expects unpunctured input.
        // If you were to build a depuncturer + Viterbi, this would change.
        // For now, let's keep the check as the current Viterbi expects pairs.
        if (cleanedSequence.length % 2 !== 0) { 
             showDecoderError("Decoder expects an unpunctured sequence (length multiple of 2)."); return;
        }
        if (parseInt(numOrigBits) < 0) {
             showDecoderError("Number of original message bits cannot be negative."); return;
        }
        
        try {
            const response = await fetch('/decoder/load_sequence', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    received_sequence: cleanedSequence, 
                    num_original_message_bits: parseInt(numOrigBits)
                }),
            });
            const data = await response.json(); 
            if (!response.ok) {
                showDecoderError(data.message || `Error: ${response.status}`);
            } else {
                showDecoderNotification(data.message || "Sequence processed.", data.status === "success" ? "success" : "info");
            }
            if (data.event) displayDecoderEventDetails(data.event);
            if (data.decoder_state) updateDecoderUIFromState(data.decoder_state);

        } catch (error) { 
            console.error("Fetch error in loadSequenceButton:", error);
            showDecoderError('Network or client-side parsing error: ' + error.message); 
        }
    });
    nextAcsStepButton.addEventListener('click', async () => { /* ... as before ... */ });
    performTracebackButton.addEventListener('click', async () => { /* ... as before ... */ });
    resetDecoderButton.addEventListener('click', async () => { /* ... as before ... */ });

    // --- Initial Page Load ---
    document.addEventListener('DOMContentLoaded', () => {
        fetchInitialEncoderConfig(); // Load puncturing schemes and initial encoder state
        
        // Initial Decoder UI state (can also be fetched if it were dynamic)
        const initialDecoderNumStates = 64;
        updateDecoderUIFromState({
            is_sequence_loaded: false, current_trellis_stage_idx: 0, T_stages_total: 0,
            is_acs_complete: false, is_traceback_complete: false,
            path_metrics: [0.0].concat(Array(initialDecoderNumStates - 1).fill(null)),
            decoded_message_final: [], num_original_message_bits: 0,
            fixed_params: { K: 7, G_octal: ["171", "133"], num_states: initialDecoderNumStates }
        });
        document.querySelector('.tab-button.active').click(); 
    });

</script>
</body>
</html>